# 王垠博客阅读笔记
地址: `http://www.yinwang.org/`

## 博客章节
* 解谜英语语法
* 解谜计算机科学

    1. 表达式是一种递归定义
    2. 并行计算的几个重点：问题的复杂度、计算单元的能力、通信开销
    3. 变量、赋值，
    4. 编译(等价翻译、减小复杂度、语法分析)
    5. 函数(数据管道、数据处理)
    6. 函数参数(就是未知数)
    7. 函数命名f(x) = t * 2
    8. 函数调用
    9. 分支
    10. 字符串、布尔值(布尔表达式)

* 从苹果产品的设计错误学教训
* 智能合约和形式验证
* iPhone X
* 理性的力量
* 我为什么爱猫
* 如何掌握所有的程序语言

    深入语言特性 + 尝试实现 -> 触类旁通

* 带猫回国经历
* DSL
* Kotlin 和 Checked Exception
* 什么是现实理想主义者
* 美国企业的装嫩问题
* 人工智能的局限性
* 经验和洞察力
* C 编译器优化的 Bug
* 对 Rust 语言的分析
* 测试的道理

    1. 光有重视代码质量的态度和口号不够。
        要实战、深刻的理解代码质量，什么时候该写测试、什么时候不该、该写什么样的测试。
        提高代码质量唯一的可行手段是不写测试，通过不断提炼自己的思维，写出最简单清晰但高效可解决问题的代码。
    2. 测试是有必要的但不要被测试束缚。
        代码的质量掌握在程序员手中，由代码自身体现，而不是依赖测试提升质量，关注点应该是代码自身，而不是测试。
    3. 在程序和算法定型前不要写测试。
        过早写测试会让你束缚无法修改程序，如果因为不写测试就没有把握写好程序，那就是编程基础没有掌握好。
        应该不停的打磨代码，追求简单直接直观高效，做练习，提升对代码的直觉，看到代码就在脑中有flow(就是心流，完全沉浸在代码中，对代码非常了解)。
        程序不再需要大幅改动后，再逐渐加入测试
    4. 不要为了编写测试而修改程序原本简单直接的接口。
        为了测试而修改原本优秀的接口是得不偿失的。
    5. 不要测试实现细节，应该针对接口测试，是否满足接口对外声称的功能。
        针对细节测试就像针对细节编程一样有问题。
    6. 应该针对程序性质写测试。
        即应该编写验证程序声明的性质的测试，如果当下缺少对程序声明的某一种性质的测试，那么就写一个。
        不要为每一次修复的bug写测试(除非是缺少这个bug所在的程序性质)
    7. 避免使用mock来模拟对象。
        当要测试多个模块串联使用时，应该每一个模块单独测试输入输出是否符合要求(包括边界情况)，
        然后像管道一样连接他们，形成一个更大的管道，然后继续测试是否符合要求，以此类推。
    8. 不要过分依赖自动化测试。
        人工测试也是需要的，自动化测试比较难以构造(要编写很多测试代码和测试环境的搭建)，有的时候使用
        人工测试只需要几分钟就可以完成测试。
    9. 避免写太长太耗时的测试
        太长的测试当你回过头看，自己都忘记当时想要测试什么东西了。
        太耗时，如果使用简单的输入就可以完全测试是否满足程序性质，为啥要给一个非常复杂的输入？
        测试代码有时候封装一下，可以提供良好的可读性，至少你回头看的时候知道在测试哪些东西。
    10. 独立测试。
        测试也应该像程序一样，写成模块化的，每个测试独立测试一个方面，不要重复测试。
        测试的逻辑结构应该与程序的逻辑结构大体一致(类似树形)。
    11. 避免通过字符串的比较来测试。
        将测试结果输出为字符串，然后对比两个字符串之间是否相等来判断测试结果，不可靠，容易出错。
        应该通过结构化的比较，如果是json数据，则parse成两个对象，然后比较两个对象的结构化数据。
    12. 测试可以帮助后来人的误区。
        测试再严密，如果测试代码或者产品代码很差，后来人也无法理解。
        所以还是那个问题，重点不在测试，而在如何编写出更清晰、优秀、简单直接的产品代码。



* Tesla autopilot 引起致命车祸
* 养生节目的危害
* IT业给世界带来的危机
* Java 有值类型吗？

    栈上的是值类型因为临时交换数据，倾向于临时使用，通过栈清空处理
    堆上的是引用类型，因为通过指针读取/写入值，倾向于共享使用，通过gc或者rc处理


* Swift 语言的设计错误

    应该设计引用类型，而swift设计成值类型。

* 正面思维的误区

    要学会看到事情负向的一面，并综合正向一面一起考量，才可以中性客观的判断和选择。

* 博文的自愿付费方式
* 为什么自动车完全不可以犯错误
* AlphaGo与人工智能
* 不要去SeaWorld
* 我看自动驾驶技术
* 给Java说句公道话

    java是王垠相对推荐的语言
    还有欣赏scheme


* Tesla Autopilot
* Tesla Model X的车门设计问题
* Tesla Model S的设计失误
* 编程的智慧
    1. 反复推敲代码
    2. 写优雅的代码(if最好有2个分支)
    3. 模块化(逻辑意义上), 函数代码不超过40行,拆分函数, 闭上眼睛在脑中模拟代码
    4. 函数应该只做一件简单的事情，逻辑应该高度内聚，如果一个函数里有多种不同的执行逻辑，应该拆分到单独的函数中
    5. 如果函数内部大部分逻辑内聚，有少量不同，则将相同的拆分出去作为共享，然后再将不同的拆分
    6. 如果两个函数间要传递数据，尽量减少使用共享的变量(全局变量或类变量都算)，应该使用局部变量或者返回值来传递，
        这样的好处的两个函数不需要依赖于一个共享的变量，函数间是松散的。如果依赖一个共享变量，则三者是耦合的
        理解：尽量两个函数直接交互，而不要通过第三方通道来传递或转发
    7. 可读性非常重要
        1. 使用有意义且对执行逻辑表达准确的函数、变量名字
        2. 局部变量的定义应该尽量接近第一次使用的地方，这样更合理，因为中间不会发生其他的修改操作
        3. 局部变量名不要太长，应该根据上下文来取名，超过3个单词的局部变量名不合适
        4. 不要重复使用同一个局部变量，应该将局部变量的作用域减少到最小
        5. 将复杂的逻辑封装到函数中并使用有意义的名字，可以减少注释量
        6. 尽量少的使用嵌套函数调用，应该换成中间变量，并取有意义的名字，可读性更强
        7. 换行。换行无法表达程序逻辑，但是应该帮助用户更好的理解程序逻辑。
        8. 写简单的代码。并不是语言提供什么，你就一定要把它用上的。
            避免使用自增减表达式 i++   ++i这些只应该在两种情况下使用：for的更新操作i++和单独一行i++;
            即使只有一条语句，也加上花括号
            合理使用括号，即使可以使用使用，也考虑加上括号是否更容易理解表达式的优先级
            避免在循环中使用continue和break(可以使用return)，循环应该正面描述应该做什么，且只由循环判断来控制流程
                1. 将continue条件反向可以去掉continue，这样可以更加正面的描述循环"应该"做什么，而不是"不应该"做什么
                2. 将break的条件合并到循环判断中可以去掉break
                3. 如果break后就是return，则将break替换成return，可以减少局部变量作用域和break的使用
                4. 复杂逻辑提取到单独函数中或者共享函数中，以替换continue或者break
        9. 写直观的代码。不要在if中添加过多的逻辑判断
        10. 写无懈可击的代码(即不含有隐藏漏洞)，if应该有两个(或多个)分支以包含所有可能的情况，不要漏掉corner case
            目的是为了穷举所有可能的情况，且明确的说明如何处理每一种
    8. 正确处理错误。尽量在异常出现的当时就作处理。一个函数中若有两个调用都可能产生异常，应该分开try，不要放在一起try。
        函数调用者应理解接口返回值的种类和意义，并第一时间处理特殊的返回值如None，异常等，即使要向上抛出也应在当层做必要的处理。
        函数作者应该明确指定接口调用签名(尤其是参数类型)，对于不允许的类型应该明确说明并抛出异常。
        特别注意处理空指针。
        数据的访问应该遵守：类型检查+访问，两个操作强制原子性。
    9. 防止过度工程，不要过多考虑将来，应该重点考虑当前要解决的问题。
        过度考虑将来的需求
        过度考虑代码的重用可能
        过度考虑测试
        测试是必要的，但不应该作为编程的主导。代码质量大部分应该是设计和规划出来的，测试只负责基本的验证和极端情况下的测试。
        仅在需要重构的时候重构，如果当前代码可以满足需求，就不需要为了可能发生的需求重构
        被动重构不代表可以随意编写可执行的代码，任何时刻代码的编写都应该简单、高效、遵守设计原则。
        练习的时候除外(怎么折腾都行)。


* 图灵的光环

    对图灵成就的解读

* 对 Parser 的误解

    解释器负责将文本代码转换成抽象数据结构AST，后续让编译器使用。
    解释器负责的工作核心是解码。
    解释器的定位并不高，更重要的是编译器和语言设计。

* 数学和编程

    并不需要非常高深的数学基础才能学好编程，两者没有太大联系。

* 谈程序的正确性

    不应该仅用正确性来衡量一个程序。
    最重要的标准应该是看他能否有效的解决问题。
    提出问题 -> 解决问题 -> 证明正确
    程序没有绝对100%的正确，因为你无法覆盖所有的测试条件，你只能覆盖常用的和稍微极端的条件。
    测试覆盖率只是代表在某种测试条件下执行那条代码没有出错，但还有千千万万种测试条件需要测试，
        所以100%代码测试覆盖率也证明不了程序的100%正确(在已测试的条件下那是可以)
    所以应该针对常用和少数极端条件下做100%覆盖率测试，就够了(不要考虑什么太阳黑子、地球爆炸带来的程序错误问题)
    而且程序的正确性很大一部分来源于编码阶段(即质量高低很大程度来源于创造时期，而不是测试时期)
    所以再创造时期要特别注意好的编码习惯和原则，这样可以提升很高的正确率，再用测试做些验证和补充。
    王垠的思想是：不停打磨代码让它一眼看上去就明显没有错误。

* 编程的宗派

    批判性思维考量所有的语言，编程的实质是编程而不是语言，语言只是思维的符号描述。

* 智商的圈套
* 为什么拍照是个坏习惯
* 设计的重要性
* 不要做聪明人
* 怎样尊重一个程序员
* 所谓“人为错误”
* 其他人的BUG
* 创造者的思维方式
* 小费和中国人的尊严
* 牛校综合征

    无

* 我和 Google 的故事（2015 修订版）

    无

* 谈创新
* 贡献和价值
* 谦虚不是一种美德
* 怎样成为一个天才

    创新的能力
    从动手中学习，深入理解事物的本质
    勤奋的努力
    正确/巧妙的学习方法  -- 读一本简短的书，花比读书更多的时间去思考书里的知识(不要读厚书，读完你思考时完全完了第一章写什么)
    仔细检查头脑里的思想，审视它们的正确性，要打破别人设下的思维圈套，去除脑中的各种权威
    用直觉(脑海中的图像)去思考，而不是符号(文字)，符号只是承载表述的媒介
    直觉要从自然界中逐渐获得，主动的接近世界，接近自然界时要主动的去感受
    单调的蹲在家里看书、练习会局限思维，让大脑只能看到符号、文字所表示的东西。
    需要休息，在深入的主动思考没有结果后，出去放松一下，思考会在潜意识中继续运转，有时候潜意识会突然顿悟
    就像锻炼肌肉一样，给与足够的刺激，也要给与足够的休息时间，才会最快速有效的增长。


* 关系模型的实质
* 对 Go 语言的综合评价
* 黑客文化的精髓
* 电视编剧的问题
* 一个对 Dijkstra 的采访视频
* 我的第一次和最后一次 Hackathon 经历
* 程序语言与它们的工具

    无

* RubySonar：一个 Ruby 静态分析器
* 程序语言与……

    设计应该接口简单，规则明确，可以组成出多种变化以提供强大功能

* 我和权威的故事
* PySonar2 与 Sourcegraph 集成完毕
* 丘奇和图灵
* Pydiff Python结构化程序比较工具
* 原因与证明
* Ydiff 结构化的程序比较
* 程序语言不是工具

    程序语言是材料，工具泛指编辑器、编辑环境、界面等



* 程序语言的常见设计错误(2) - 试图容纳世界
* 关于语言的思考
* Yoda 表示法错在哪里
* 几个超炫的专业词汇
* 标准化试卷标记语言
* 一种新的操作系统设计
* 论“我”和“我们”
* 谈程序的“通用性”
* 什么是启发
* Scheme 编程环境的设置
* Currying 的局限性
* 惰性求值
* 函数式语言的宗教
* 什么是“脚本语言”

    初始设计为批量执行命令，现在基于特定场景使用的“不严谨”的程序语言。应该尽量避免使用脚本语言，就算要编写脚本也应该使用“严谨”的通用程序语言如java、python、scheme等，万不得已要使用类似shell的脚本语言，也应该严格遵守程序设计原则（封装、抽象、模块化等）

* Chez Scheme 的传说
* Lisp 已死，Lisp 万岁！
* 论对东西的崇拜
* “解决问题”与“消灭问题”
* 程序语言的常见设计错误(1) - 片面追求短小
* 谈语法
* Oberon 操作系统：被忽略的珍宝
* 谈 Linux，Windows 和 Mac

    linux的使用太难及过于复杂，面向用户支持不够友好
* 解密“设计模式”

    设计模式就相当于，我们在做项目的时候，应该用什么样的方式去完成。
    前人总结出了PMP的项目管理方法，这是一个指导性的原则。
    我们应该根据具体项目需求灵活的调整，选择最合适当下的方法去实施项目。
    而不是硬性要求按照PMP的10大过程组一个个执行。
    设计模式也是这样，我们应该深刻理解设计模式的思想，然后在项目中根据具体情况灵活运用即可。
    而不是生搬硬套一定要使用某种模式去设计。
    此外，设计模式站在很高的抽象层次，所以只有在代码规模足够大的情况下才使用设计模式来发挥它的能力。

* Braid - 一个发人深思的游戏
* TeXmacs：一个真正“所见即所得”的排版系统
* 怎样写一个解释器

    写的很好，很深入实质原理

* 什么是语义学
* GTF - Great Teacher Friedman
* 什么是“对用户友好”

    设计上尽量统一的接口调用规则、
    合理的抽象（用户可见范围的控制）、
    提供充分而不多于必要的功能（或接口），就是穷尽却不高于期望、
    正交（即功能之间不应该耦合或者重复，应该相互独立）、
    理性（应该搞明白哪些功能是用户真正需要的，大部分用户并不知道，所以应该由设计者思考并提供真正有用的功能）、
    直觉（让用户感觉设计是立体或者说有直观感受的）、
    上下文管理（不要给用户展示全部上下文，应该只展示当前需要的，因为用户记不住）。
