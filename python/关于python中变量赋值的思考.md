## 基本语言特性
变量赋值，是python中最简单的使用。它虽然简单，却包含了非常多的底层原理。我在开始学习python的时候，仅仅是将变量赋值这种操作当成是编程语言理所应当提供的功能，从未深入的考虑到它涉及到的底层技术。现在，我希望可以按照自己的思考记录下我对python中变量赋值的理解。此外，变量赋值是绝大部分编程语言都实现的功能，所以它应该是一个**基本语言特性**。


## 变量赋值的例子
拿出一个最简单的例子作为说明：
```python3
a = 23
```
这应该是我在python中写的最多的语句，它涵盖了如下我会深入思考的知识点：
- 变量名和内存地址的关系
- python中到底是值传递还是引用传递
- 判断对象相等性
- 访问变量的步骤
- 动态类型导致的维护/排错工作量上升
- 数据在栈上和堆上的区别

现在，我要将自己的思考内容记录到文章当中，逐一对上述知识表达自己的观点。因为从零开始学习python才经过9个月，所以还有很多底层知识没来得及补全，可能会有错误和表达不准确的地方，但是大方向上应该是没错的。

## 变量名和内存地址的关系
当我们要求python创建一个数字23的时候，操作系统会为我们在内存中的某一个位置开辟一个空间，存入23后返回此空间的内存地址，后续我们可以通过对内存地址执行“指针操作”以访问数据23。**变量名是内存地址的别称，它让我们可以用一串“有含义”的字符串代表某一个16进制的内存地址序列，这降低了我们的记忆负担，同时提升了程序的可读性。换句话说，变量名“等价于”内存地址。**

事实上我们的确可以这样去理解它，如果要举一个我熟悉的例子来类比的话，那就是：用域名`www.xxx.com`来代表一个IP地址`10.1.231.11`，域名让我们不需要记忆IP，却又提升了可读性，而域名和IP地址表示的是同一个目的地。

注意：域名和IP地址之间正确解析的前提是存在一份映射表，所以类比思考的话，所有支持变量的程序语言中，底层应该保存着一份变量名到内存地址的映射表。

## python中到底是值传递还是引用传递
刚刚开始学习python的时候，入门课程中就开始分析值传递和引用传递，网络上也有很多的说法，这一度让我陷入混乱，不知道哪一种才是正确的。**现在我想表达一下我自己的观点：python中只有引用传递。**

一个经常被使用的例子：
```python3
a = 23
b = a
```
我来猜测一下这两条语句的执行步骤：
1. 要求创建一个数据23，操作系统返回一个内存地址，python使用a来代表此地址，并记录到映射表中。
2. python使用a作为索引，从映射表中获取此索引对应的值，即数据23的内存地址。
3. python将b以及数据23的内存地址存入映射表中。

所以不论是在函数传参、函数返回、为对象赋值等场景中，变量都是引用传递。引用传递使得我们可以将“变量名”和“真实数据”分离开，我们只需要维护一张映射表即可。同时，引用传递表达了“共享数据”的观念，“真实数据”只需要在内存中存在一份，通过多份引用来共享这一份数据，我们对“真实数据”的操作更加的轻量化。

相比而言，值传递就会带来如下问题：
- 传递时需要复制数据，对于复合数据，尤其是大数据量时的开销很大，因为需要把整个数据完整copy一份。
- 无法共享数据，即使copy后的数据与原数据的值一样，但是它们的地址是不同的。
- 数据不能存放在堆上，只能存放在栈上，这使得数据倾向于变成“临时性数据”。

## 判断对象相等性
如果你认可python中的变量是引用传递，那么如何判断对象相等性就非常容易理解，且容易实现。
- 对象有值相等和地址相等之分。
- 判断地址相等使用is，通过映射表就可以判定。
- 判断值相等使用==，需要判断整颗属性树。

## 访问对象的步骤
将变量名作为索引，在映射表中找到对应的内存地址，向操作系统发起访问请求读取指定位置的数据。

## 动态类型导致的维护/排错工作量上升
在静态类型的语言中，比如c和java，一个变量的定义需要声明它的类型，若为一个A类型的变量赋值了另一个B类型的值，将会编译失败，而且即使是在运行中重新赋值，也必须给与正确的类型。

我觉得硬性的类型判断是非常好的语言特性，它带来了如下好处：
- 强迫思考变量的类型对程序员有好处，可以提升对程序中数据的理解
- 减少对一个变量类型判断的歧义，这间接的降低了思考的负担
- 提升对程序安全性的把控，降低了类型错误问题
- 提升了契约化编程的概念，让源代码看上去就像“明文规定”一样

相反，动态类型会带来一大堆麻烦的事情，对，python也是其中一员：
- 增加了思考的负担，无法简单的看出对象的类型，需要通过上下文或者注释才能判断
- 发生TypeError的时候，无法快速定位是哪里出现了类型错误，尤其错误类型是NoneType的时候
- 调用其他人写的函数时没有安全感，因为无法保证那个函数不会返回一个“约定之外”的数据类型
- 基本没有数据类型上的契约化，单纯靠注释和上下文判断，源代码看上去像“明文约定”，有些程序员甚至连约定都不写

对于动态类型和静态类型，我的看法是：一个编程语言应该既能支持静态类型，又能支持动态类型，让程序员可以有选择的余地。就像java那样，默认是静态类型，但也可以支持泛型，可进可退。而python就做的不好，默认支持泛型，而使用静态类型却很不方便（要用array来实现静态类型的数组，而且没有将静态类型应用到所有场景）

虽说动态类型语言编码时更加快速、灵活，然而带来的却是更多的事后维护工作。处如果让我选择一门语言编写大型重要项目时，我不会选择python作为主要语言。

## 数据在栈上和堆上的区别
堆上的数据倾向于“共享”，每次我们实例化一个对象的时候，都要向内存申请堆空间，每次我们不再使用一个对象的时候，都要向内存申请释放对空间（c语言是程序员申请，python是自动申请）。堆上的数据使用引用来访问，垃圾回收机制也是针对堆空间的回收，堆上的数据是面向整个程序使用的，可以理解为是整个程序的执行环境。

栈作为函数调用的实现结构，承载着当前函数的数据。栈上的数据倾向于“临时”，每次进入一个函数时都需要增加一个栈帧，每次退出一个函数的时候都需要弹出一个栈帧，这样，栈上的数据就很自然的被“清空”而不需要特地的执行垃圾回收。栈上的数据是面向当前执行函数的，可以理解为是当前函数的执行环境。